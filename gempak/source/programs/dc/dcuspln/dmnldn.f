	SUBROUTINE DMNLDN ( isffln, ihhmm, iheadr, sfdata, iret )
C************************************************************************
C* DMNLDN								*
C*									*
C* This subroutine writes a station header and station data to a	*
C* NLDN lightning data surface file.					*
C*									*
C* Generated by combining DM_WCLH, and DM_WDTR, and then		*
C* streamlining for real time decoding.					*
C*									*
C* DMNLDN ( ISFFLN, IHEADR, FIRST, IPOS, ICOUNT, IRET )			*
C*									*
C* Input parameters:							*
C*	ISFFLN		INTEGER		Surface file number		*
C*	IHHMM		INTEGER		GEMPAK station time		*
C*	IHEADR (MMKEY)	INTEGER		GEMPAK data header		*
C*	SFDATA (NPARM)	REAL		GEMPAK data			*
C*									*
C* Output parameters:							*
C*	IRET		INTEGER		Return code			*
C*				    	   0 = normal return		*
C*					  -1 = error writing buffers	*
C*					  -2 = posit in buffer error	*
C*					 -10 = error with data file	*
C*					 -12 = no space left in file	*
C**									*
C* Log:									*
C* M. desJardins/GSFC	 2/88						*
C* M. desJardins/GSFC	 6/88	Documentation				*
C* P. Bruehl/Unidata	 4/94   Modified for real time lightning ingest *
C************************************************************************
	INCLUDE		'GEMPRM.PRM'
	INCLUDE		'GMBDTA.CMN'
	INCLUDE		'nldn.prm'
	INCLUDE		'dmcmn.cmn'
C*
	CHARACTER	error*160
	REAL		sfdata (*)
C*
	INTEGER		iheadr (*)
C*
	INCLUDE		'ERMISS.FNC'
C------------------------------------------------------------------------
	iptcnt = icount 
	ibuffer = 500
C
C*	If this is the FIRST time through this subroutine, make a 
C*	series of checks.  After the first time, do not do this again.
C
	IF ( first ) THEN
C
C*      Check that user has write access to file.
C
                IF  ( .not. wflag (isffln) ) THEN
                        iret = -10
                        RETURN
                END IF
C
C*	Get part number. 
C
	    	IF  ( kprtnm ( 1, isffln ) .eq. 'SFDT' ) THEN
			iprt = 1
		ELSE 
	    		iret = -10
	    		RETURN
		END IF
C
C*	Check for valid data type. 
C
		IF  ( ktyprt(iprt, isffln) .ne. MDRPCK ) THEN
	    		iret = -10
	    		RETURN
		END IF
C
C*	Check length of data header (= 1 for stim).
C
		IF ( klnhdr ( iprt, isffln ) .ne. 1 ) THEN
			iret = -10
			RETURN
		ENDIF
C
C*	Done with FIRST time checks
C
	ENDIF
C
C*	Add header to file.
C
	jpos = 0
C
C*	Find next available location.  
C
	IF ( (ipos .lt. 0) .or. (ipos .gt. kcol (isffln)) ) THEN
C
C*	Out of space in this file
C
 	   iret = -12
	   RETURN
C
C*	If ipos=0, find next available location.
C 
	ELSE IF ( ipos .eq. 0 ) THEN
	    knt  = 1
	    kloc = knt + krow ( isffln )
C
C*	    Check each header location to see if it is used.
C
	    DO WHILE ((jpos .eq. 0) .and. (knt .le. kcol(isffln)))
		IF ( kheadr(0,kloc,isffln) .eq. IMISSD ) THEN
		    jpos = knt
		    jloc = kloc
		  ELSE
		    knt  = knt + 1
		    kloc = kloc + 1
		END IF
	    END DO
	    IF ( jpos .eq. 0 ) THEN
		iret = -12
		RETURN
	    ENDIF
C
C*	  Otherwise header location was specified.
C
	ELSE
	    jpos = ipos
	    jloc = jpos + krow ( isffln )
	END IF

C
C*	Set flag indicating header is used.
C
	kheadr ( 0, jloc, isffln ) = - IMISSD
	ihead = ihead + 1
	jheadr ( ihead ) = - IMISSD
C
C*	Store header in common and in variable.
C
	DO  i = 1, kckeys (isffln)
		kheadr ( i, jloc, isffln ) = iheadr ( i )
		ihead = ihead + 1
		jheadr (ihead) = iheadr (i)
	END DO
C
C*	Calculate where headers go (istart), 
C*		the location in common (jlocat), and length.
C
	IF ( first ) THEN
		istart = kpcolh (isffln) + (jpos-1) * (kckeys (isffln) + 1)
		jlocat = jloc
	    	length = kckeys (isffln) + 1
	ENDIF
C
C* 	Store last header used position in common.
C
	klstcl (isffln) = jpos
	icol = jpos
C
C*	Increment last used position (icol) by 1 for next time through
C
	ipos=icol+1
	irow = 1
C
C*	Prepare data array for the file.
C
C*	Check for valid column position. (We know irow = 1)
C
	IF ( ( icol .lt. 1 ) .or. ( icol .gt. kcol (isffln) ) ) THEN
	    iret = -12
	    RETURN
	END IF
C
C*	Calculate where pointer to data goes.  ONLY DO THIS
C*	THE FIRST TIME!
C
	IF ( first ) ipoint = kpdata(isffln) + (icol-1)
C
C*	Pack the data into an integer array for packed data type.
C
        CALL DM_PACK ( isffln, iprt, nword, sfdata, kword,  
     +						intarr, iret )
	IF (iret .ne. 0 ) THEN
	  WRITE (error,*) "Trouble packing GEMPAK integer data", iret
	  CALL DC_WLOG (0, 'DCNLDN ', iret, error, ier)
	  iret = -10
	  RETURN
	ENDIF
C
C*	lendat = # words + 1 for header length (ilenhd) + 1 for total length
C*	lendat = kword + ilenhd +  1
C
	lendat = kword + 1 +  1
C
C*	Get space for current data.
C*	(used to be CALL DM_GSPC  ( isffln, lendat, isdata, iret ))
C*	Allocate space at the end of the file.
C
	isdata = kpnext (isffln)
	kpnext (isffln) = kpnext (isffln) + lendat
	IF ( first ) istdat = isdata
C
C*	Write length, header (ihhmm), and data (intarr) to variable
C
	idata = idata + 1
C	iwarr (idata) = kword + ilenhd
	iwarr (idata) = kword + 1
	idata = idata + 1
	iwarr (idata) = ihhmm
	DO i = 1,kword
		iwarr(i+idata) = intarr(i)
	END DO
	idata = idata + kword
C
C*	Increment counter for buffered writes (header, pointer, and data)
C
	iptcnt = iptcnt + 1
C
C*	Write pointer to variable. 
C
	iptlist (iptcnt) = isdata

	IF ( iptcnt .eq. ibuffer ) THEN
C
C*	Time to write buffers to file
C
C*	Write data management block to file
C
	  CALL DM_WDMG ( isffln, iret )
          IF ( iret .ne. 0 ) THEN
            iret = -1
            RETURN
          ENDIF
C
C*	Write column headers to file
C
	  IF ( istart .eq. 0 )  THEN
	         iret = -2
       		 RETURN
	  ENDIF
	  ilen = length * iptcnt
	  CALL DM_WINT ( isffln, istart, ilen, jheadr, iret)
	  IF ( iret .ne. 0 ) THEN
		iret = -1
		RETURN
	  ENDIF
C
C*	Write data pointers to file
C
	  IF ( ipoint .eq. 0 )  THEN
		iret = -2
		RETURN
	  ENDIF
	  CALL DM_WINT ( isffln, ipoint, iptcnt, iptlist, iret )
	  IF ( iret .ne. 0 ) THEN 
		iret = -1
		RETURN
	  ENDIF
C
C*	Write data to file
C
	  IF ( istdat .eq. 0 ) THEN
		iret = -2
		RETURN
	  ENDIF
	  ilen = lendat * iptcnt
	  CALL DM_WINT ( isffln, istdat, ilen, iwarr, iret )
	  IF ( iret .ne. 0 ) THEN
		iret = -1
		RETURN
	  ENDIF 
C
C*	Increment ipoint by icol, rather than icol-1, because we haven't 
C*	moved to the next open column yet. 
C*      Increment ipoint, istart, istdat; reset iptcnt, idata, ihead;
C*      zero out pointer, data, and header arrays.
C
	  ipoint = kpdata (isffln) + (icol)
	  istart = istart + (length * iptcnt)
	  istdat = kpnext (isffln)
	  iptcnt = 0
	  idata = 0
	  ihead = 0
	  DO iclean = 1, ibuffer
		iptlist (iclean) = 0
	  END DO
	  DO iclean = 1, ( ( MMPARM+2 )*ibuffer )
		iwarr (iclean) = 0
	  END DO
          DO iclean = 1, ( ibuffer * 10 )
 	         jheadr (iclean) = 0
	  END DO 
	ENDIF
C
C*	Finish up this pass through the loop
C
	icount=iptcnt
	first=.false.
C*
	RETURN
	END

